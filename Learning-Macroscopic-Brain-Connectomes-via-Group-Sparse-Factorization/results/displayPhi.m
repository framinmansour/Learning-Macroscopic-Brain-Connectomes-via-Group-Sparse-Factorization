function displayPhiDiff(Phi, orients, coords, lineSpec)
    % Displays Fascicles
    % Arguments:
    % Phi - the tensor Phi, trimmed to only contain the fascicles to be
    %       displayed, (use Phi(:,:,[a:b,c:d]) for fascicles a through b and c
    %       through d)
    %       To use a Phi generated by brain.m, use Phi(:,vind,:)
    % orients - fe.life.M.orient, map of indices in Phi to actual
    %           orientations (sometimes fe.life.M.Atoms.orient instead)
    % coords - fe.roi.coords, map of indicies in Phi to actual coordinates
    %          when generating Phi from brain.m, use fe.roi.coords(vlist,:)
    % Here is how to plot the results:
    % 1. Load either of the fe_struct_... files depending on if you want the ARC_SFL or Arcuate dataset.
    % 2. From the stage1 folder load the .mat file corresponding to the data that would be saved at the
    % end of stage 1 in the test you want to plot. The filename is of the form Phi_<Nsv>_<datasetIndex>_<stage1>_<numOrient>_<regtage1>.
    % 3. If you will want to plot the Phi at the end of stage 1 (such as if it was initialized with Phi_expert, which you also want to plot) skip to step 4. 
    % 3. From the subsets folder for Arcuate (dataIndex = 1) or the newsubsets folder for ARC_SFL (dataIndex = 2), load the Phi you want to plot.
    % Note: this Phi should have been generated using the same parameters as the Phi loaded in step 2 (i.e. the first 5 numbers in the filename match).
    % 4. Run displayPhi(Phi_sp(:,vind,:),fe.life.M.Atoms.orient,fe.roi.coords(vlist,:))

    % inverse of coords, lookup index from coordinates
    coordsMap = containers.Map('KeyType', 'char', 'ValueType', 'double');
    for c = 1:length(coords)
        coordsMap(mat2str(coords(c,:))) = c;
    end
    
    function [directions, locations] = addNode(directions, locations, node, mode, weight)
        persistent lastDir;
        persistent loc;
        if (length(mode) > 1)
            loc = mode;
            if isempty(directions)
                lastDir = [0 0 0]';
            else
                lastDir = directions(:,1);
            end
            return
        end
        dir = orients(:,node);
        dir = dir * weight/norm(weight);
%         dir = dir/norm(dir) * 2/3;
        
%         dir = dir/norm(dir) * weight;
%         if gt
%        dir = [-1,0,0,;0,1,0;0,0,0] * [-1,0,0,;0,1,0;0,0,-1] * dir;
%         end
%         dir = dir/norm(dir) * weight * 2.1;
            
        
        angleDif = atan2d(norm(cross(lastDir, dir)), dot(lastDir, dir));
        if angleDif > 90 || angleDif < -90
            dir = -dir;
        end
        if mode == -1
            loc = loc - dir.';
            locations = [loc; locations];
        end
        lastDir = dir;
        %locations = [locations; loc];
        directions = [directions, dir];
        if mode ~= -1
            locations = [locations; loc];
            loc = loc + dir.';
        end
    end
    
    function beginningVoxel = getFirstVoxel(voxelInds, seenMap)
        fewestNeighbours = [Inf, Inf, Inf];
        for v = voxelInds.'
            if ~seenMap.isKey(v)
                neighboursAll = getAllNeighbours(v, voxelInds, seenMap);
                numNeighbours = [length(neighboursAll{1}), length(neighboursAll{2}), ...
                                        length(neighboursAll{3})];
                if sum(numNeighbours) < sum(fewestNeighbours)
                    beginningVoxel = v;
                    fewestNeighbours = numNeighbours;
                elseif sum(numNeighbours) == sum(fewestNeighbours)
                    if sum(numNeighbours(1:2)) < sum(fewestNeighbours(1:2))
                        beginningVoxel = v;
                        fewestNeighbours = numNeighbours;
                    elseif sum(numNeighbours(1:2)) == sum(fewestNeighbours(1:2)) && ...
                            numNeighbours(1) < fewestNeighbours(1)
                        beginningVoxel = v;
                        fewestNeighbours = numNeighbours;
                    end
                end
            end
        end
    end

    function neighboursAll = getAllNeighbours(currentIndex, indices, seenMap)
        coord = coords(currentIndex,:);
        neighboursAll = {[];[];[]};
        for i = -1:1
            for j = -1:1
                for k = -1:1
                    row = abs(i) + abs(j) + abs(k);
                    lookup = mat2str(coord + [i, j, k]);
                    if (row ~= 0 && coordsMap.isKey(lookup))
                        lookupIndex = coordsMap(lookup);
                        if (~seenMap.isKey(lookupIndex) && ...
                                ismember(lookupIndex, indices(:)))
                            neighboursAll{row} = [neighboursAll{row}, coordsMap(lookup)];
                        end
                    end
                end
            end
        end
    end
    
    function neighbours = getNeighbours(currentIndex, indices, seenMap)
        neighboursAll = getAllNeighbours(currentIndex, indices(:,2), seenMap);
        neighbours = [neighboursAll{1}, neighboursAll{2}, neighboursAll{3}];
        if isempty(neighboursAll{1}) == 0
            %neighbours = neighboursAll{1};
        elseif isempty(neighboursAll{2}) == 0
            %neighbours = neighboursAll{2};
        elseif isempty(neighboursAll{3}) == 0
            %neighbours = neighboursAll{3};
        else
            neighbours = [];
        end
    end

    function closest = getNode(current, neighbours, nodes)
        %currentVoxelNodes = nodes(find(nodes(:,2) == current),1);
        currentVoxelNodes = nodes(nodes(:,2) == current,1);
        closestDiff = Inf;
        found = 0;
        for currentNode = currentVoxelNodes.'
            currentNodeOrient = orients(:,currentNode);
            for neighbour = neighbours
                %neighbourNodes = nodes(find(nodes(:,2) == neighbour),1);
                neighbourNodes = nodes(nodes(:,2) == neighbour,1);
                for neighbourNode = neighbourNodes.'
                    neighbourNodeOrient = orients(:,neighbourNode);
                    difference = atan2d(norm(cross(currentNodeOrient, ...
                                 neighbourNodeOrient)), dot(currentNodeOrient, ...
                                 neighbourNodeOrient));
                    if difference > 90
                        difference = 180 - difference;
                    elseif difference < -90
                        difference = -180 + difference;
                    end
                    if (abs(difference) < closestDiff)
                        found = 1;
                        closestDiff = difference;
                        closest = [neighbourNode, neighbour, currentNode];
                    end
                end
            end
        end
        if ~found
            closest = [];
        end
    end

    colourIndex = 0;
    % if only one fascicle used, Phi will be two dimensional
    if ndims(Phi) == 3
        % Remove any fascicle slices with no non zeroes
        % These may occur when generating Phi with a small Nsv
        newPhi = sptensor([], [], size(Phi));
        numFascicles = 0;
        for f = 1:size(Phi, 3)
            if nnz(Phi(:,:,f)) ~= 0
                numFascicles = numFascicles + 1;
                newPhi(:,:,numFascicles) = Phi(:,:,f);
            end
        end
        Phi = newPhi(:,:,1:numFascicles);
    else
        if nnz(Phi) == 0
            numFascicles = 0;
        else
            numFascicles = 1;
        end
    end
    if numFascicles == 0
        disp("No non zero fascicles in Phi");
    end
    % loop over all fascicles
    for f = 1:numFascicles
        if mod(f,100) == 0
            fprintf("Fascicle %d of %d\n", f, numFascicles);
        end
        prevNode = [];
        seenMap = containers.Map('KeyType', 'double', 'ValueType', 'double');
        if ndims(Phi) == 3
            fascicle = Phi(:,:,f);
        else
            fascicle = Phi;
        end
        fascicle = fascicle / max(fascicle.vals);
        voxelNodes = fascicle.subs; % get all nonzeroes
        voxelIndices = unique(voxelNodes(:,2));
        directionsFull = [];
        locationsFull = [];
        count = 0;
        while length(seenMap.keys()) < length(voxelIndices)
            count = count + 1;
            directions = [];
            locations = [];
            firstVoxel = getFirstVoxel(voxelIndices, seenMap);
            numFirstVoxelNodes = length(find(voxelNodes(:,2) == firstVoxel));
            seenMap(firstVoxel) = 1;
            % Find Next Node
            neighbours = getNeighbours(firstVoxel, voxelNodes, seenMap);
            nextNode = getNode(firstVoxel, neighbours, voxelNodes);
            if ~isempty(nextNode)
                seenMap(nextNode(2)) = 1;
                % Plot nodes in first voxel
                if numFirstVoxelNodes == 3
                    firstNodes = voxelNodes(voxelNodes(:,2) == firstVoxel,1);
                    firstNodes = firstNodes(firstNodes ~= nextNode(3));
                    node1Orient = orients(:,firstNodes(1));
                    node2Orient = orients(:,firstNodes(2));
                    node3Orient = orients(:,nextNode(3));
                    diff1 = abs(atan2d(norm(cross(node1Orient, node3Orient)), ...
                                          dot(node1Orient, node3Orient)));
                    diff2 = abs(atan2d(norm(cross(node2Orient, node3Orient)), ...
                                          dot(node2Orient, node3Orient)));
                    if diff1 > 90
                        diff1 = 180 - diff1;
                    end
                    if diff2 > 90
                        diff2 = 180 - diff2;
                    end
                    if diff1 > diff2
                        firstNode = firstNodes(1);
                    else
                        firstNode = firstNodes(2);
                    end
                elseif numFirstVoxelNodes == 2
                    firstNodes = voxelNodes(voxelNodes(:,2) == firstVoxel,1);
                    firstNodes = firstNodes(firstNodes ~= nextNode(3));
                    firstNode = firstNodes;
                else
                    firstNode = nextNode(3);
                end
                [directions, locations] = addNode(directions, locations, ...
                                                  0, coords(firstVoxel,:), fascicle(coords(firstVoxel,:),firstVoxel));
                [directions, locations] = addNode(directions, locations, ...
                                                  firstNode, 0, fascicle(firstNode,firstVoxel));
                if numFirstVoxelNodes > 1
                    if numFirstVoxelNodes == 3
                        firstNodes = voxelNodes(voxelNodes(:,2) == firstVoxel,1);
                        firstNodes = firstNodes(firstNodes ~= nextNode(3));
                        if ~isempty(prevNode) && ismember(prevNode(3), firstNodes)
                            firstNodes = firstNodes(firstNodes ~= prevNode(3));
                        else
                            firstNodes = firstNodes(firstNodes ~= firstNode);
                        end
                        [directions, locations] = addNode(directions, locations, ...
                                                  firstNodes, 0, fascicle(firstNodes,firstVoxel));
                    end
                    [directions, locations] = addNode(directions, locations, ...
                                                  nextNode(3), 0, fascicle(nextNode(3),firstVoxel));
                end
                % End plot node in first voxel
                %disp("First");
                %disp(coords(firstVoxel,:));
                %disp("Forward");
                currentVoxel = nextNode(2);
                lastNeighbours = [currentVoxel];
                 % Forward Loop
                while 1
                    %disp(coords(nextNode(2),:));
                    %Order Nodes in current voxel
                    currentNodes = voxelNodes(voxelNodes(:,2) == nextNode(2),1);
                    [directions, locations] = addNode(directions, locations, ...
                                                  nextNode(1), 0, fascicle(nextNode(1),nextNode(2)));
                    lastNode = nextNode(1);
                    if length(currentNodes) == 3
                        currentNodes = currentNodes(currentNodes ~= nextNode(1));
                        node1Orient = orients(:,nextNode(1));
                        node2Orient = orients(:,currentNodes(1));
                        node3Orient = orients(:,currentNodes(2));
                        diff1 = atan2d(norm(cross(node1Orient, node2Orient)), ...
                                              dot(node1Orient, node2Orient));
                        diff2 = atan2d(norm(cross(node1Orient, node3Orient)), ...
                                              dot(node1Orient, node3Orient));
                        if (diff1 < diff2)
                            [directions, locations] = addNode(directions, locations, ...
                                                                currentNodes(1), 0, fascicle(currentNodes(1),nextNode(2)));
                            [directions, locations] = addNode(directions, locations, ...
                                                                currentNodes(2), 0, fascicle(currentNodes(2),nextNode(2)));
                            lastNode = currentNodes(2);
                        else
                            [directions, locations] = addNode(directions, locations, ...
                                                                currentNodes(2), 0, fascicle(currentNodes(2),nextNode(2)));
                            [directions, locations] = addNode(directions, locations, ...
                                                                currentNodes(1), 0, fascicle(currentNodes(1),nextNode(2)));
                            lastNode = currentNodes(1);
                        end
                    elseif length(currentNodes) == 2
                        [directions, locations] = addNode(directions, locations, ...
                                              currentNodes(currentNodes ~= nextNode(1)), 0, ...
                                              fascicle(currentNodes(currentNodes ~= nextNode(1)),nextNode(2)));
                        lastNode = currentNodes(currentNodes ~= nextNode(1));
                    end
                    lastVoxel = nextNode(2);
                    locInd = size(locations,1);
                    % End order nodes in current voxel
                    neighbours = getNeighbours(currentVoxel, voxelNodes, seenMap);
                    if isempty(neighbours)
                        neighbours = getNeighbours(nextNode(2), voxelNodes, seenMap);
                        currentVoxel = nextNode(2);
                        if isempty(neighbours)
                            while ~isempty(lastNeighbours)
                                lastNeighbour = lastNeighbours(end);
                                lastNeighbours = lastNeighbours(1:end-1);
                                neighbours = getNeighbours(lastNeighbour, ...
                                                            voxelNodes, seenMap);
                                if ~isempty(neighbours)
                                    break
                                end
                            end
                            if isempty(neighbours)
                                break
                            end
                        end
                    end
                    nextNode = getNode(nextNode(2), neighbours, ...
                                       voxelNodes(voxelNodes(:,2) ~= firstVoxel | ...
                                                  voxelNodes(:,1) == lastNode,:));
                    lastNeighbours = [lastNeighbours, nextNode(2)];
                    seenMap(nextNode(2)) = 1;
                end
                % End Forward Loop
                addNode(directions,locations,0,coords(firstVoxel, :), fascicle(coords(firstVoxel, :),nextNode(2)));
                % Find Previous Node
                neighbours = getNeighbours(firstVoxel, voxelNodes, seenMap);
                if numFirstVoxelNodes == 1
                    prevNode = getNode(firstVoxel, neighbours, voxelNodes);
                else
                    % If more than one node in this voxel, omit node found for next
                    % node from connecting to previous node
                    prevNode = getNode(firstVoxel, neighbours, ...
                                   voxelNodes(voxelNodes(:,1) ~= firstVoxel | ...
                                   voxelNodes(:,2) == firstNode,:));
                end
                % Backwards Loop
                if ~isempty(prevNode)
                    %disp("Backwards");
                    currentVoxel = prevNode(2);
                    seenMap(prevNode(2)) = 1;
                    while 1
                        %disp(coords(prevNode(2),:));
                        %Order Nodes in current voxel
                        currentNodes = voxelNodes(voxelNodes(:,2) == prevNode(2),1);
                        [directions, locations] = addNode(directions, locations, ...
                                                            prevNode(1), -1, fascicle( prevNode(1),nextNode(2)));
                        lastNode = prevNode(1);
                        if length(currentNodes) == 3
                            currentNodes = currentNodes(currentNodes ~= prevNode(1));
                            node1Orient = orients(:,prevNode(1));
                            node2Orient = orients(:,currentNodes(1));
                            node3Orient = orients(:,currentNodes(2));
                            diff1 = atan2d(norm(cross(node1Orient, node2Orient)), ...
                                                  dot(node1Orient, node2Orient));
                            diff2 = atan2d(norm(cross(node1Orient, node3Orient)), ...
                                                  dot(node1Orient, node3Orient));
                            if (diff1 < diff2)
                                [directions, locations] = addNode(directions, locations, ...
                                                            currentNodes(1), -1, fascicle(currentNodes(1),nextNode(2)));
                                [directions, locations] = addNode(directions, locations, ...
                                                            currentNodes(2), -1, fascicle(currentNodes(2),nextNode(2)));
                                lastNode = currentNodes(2);
                            else
                                [directions, locations] = addNode(directions, locations, ...
                                                            currentNodes(2), -1, fascicle(currentNodes(2),nextNode(2)));
                                [directions, locations] = addNode(directions, locations, ...
                                                            currentNodes(1), -1, fascicle(currentNodes(1),nextNode(2)));
                                lastNode = currentNodes(1);
                            end
                        elseif length(currentNodes) == 2
                            [directions, locations] = addNode(directions, locations, ...
                                            currentNodes(currentNodes ~= prevNode(1)), -1, ...
                                            fascicle(currentNodes(currentNodes ~= prevNode(1)),nextNode(2)));
                            lastNode = currentNodes(currentNodes ~= prevNode(1));
                        end
                        lastVoxel2 = prevNode(2);
                        locInd2 = size(locations,1);
                        % End order nodes in current voxel
                        neighbours = getNeighbours(currentVoxel, voxelNodes, seenMap);
                        if isempty(neighbours)
                            neighbours = getNeighbours(prevNode(2), voxelNodes, seenMap);
                            currentVoxel = prevNode(2);
                            if isempty(neighbours)
                                break
                            end
                        end
                        prevNode = getNode(prevNode(2), neighbours, ...
                                           voxelNodes(voxelNodes(:,2) ~= firstVoxel | ...
                                                      voxelNodes(:,1) == lastNode,:));
                        seenMap(prevNode(2)) = 1;
                    end
                end
                % End Backwards Loop
                if (exist('lastVoxel2','var')) && (norm(coords(lastVoxel2,:) -...
                        locations(1,:)) > norm(coords(lastVoxel2,:) - locations(1,:)))
                    lastVoxel = lastVoxel2;
                    locInd = locInd2;
                end
                dist1 = norm(coords(lastVoxel,:) - locations(locInd,:));
                dist2 = norm(coords(lastVoxel,:) - 2*locations(1,:) + locations(locInd,:));
                if dist2 < dist1
                    directions = -directions;
                    locations = 2*locations(1,:) - locations;
                end

            else
                firstNodes = voxelNodes(voxelNodes(:,2) == firstVoxel,1);
                numFirstVoxelNodes = length(firstNodes);
                [directions, locations] = addNode(directions, locations, ...
                                        firstNodes(1), coords(firstVoxel, :), fascicle(firstNodes(1),firstVoxel));
                [directions, locations] = addNode(directions, locations, ...
                                        firstNodes(1), 1, fascicle(firstNodes(1),firstVoxel));
                if numFirstVoxelNodes > 1
                    [directions, locations] = addNode(directions, locations, ...
                                            firstNodes(2), 1, fascicle(firstNodes(2),firstVoxel));
                    if numFirstVoxelNodes > 2
                        [directions, locations] = addNode(directions, locations, ...
                                                firstNodes(3), 1, fascicle(firstNodes(3),firstVoxel));
                    end
                end
            end
            locationsFull = [locationsFull; locations];
            directionsFull = [directionsFull, directions];
        end
        hold on
        directionsFull = directionsFull.';
        q=plot3(locationsFull(:,1), locationsFull(:,2), locationsFull(:,3), lineSpec, 'MarkerSize', 2, 'LineWidth', 1.75);
%         q=plot3(locationsFull(:,1), locationsFull(:,2), locationsFull(:,3));
%         q = quiver3(locationsFull(:,1), locationsFull(:,2), locationsFull(:,3), ...
%                     directionsFull(:,1), directionsFull(:,2), directionsFull(:,3), 0.1);
%         % assign colour to fascicle depending on how many fascicles are
%         % plotted
%         
        hsvColour(:,1) = colourIndex/numFascicles;
        hsvColour(:,2) = 1;
        hsvColour(:,3) = 1;
        q.Color = hsv2rgb(hsvColour);
        colourIndex = colourIndex + 1;
%         q.ShowArrowHead = 'off';
    end
end